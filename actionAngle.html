<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Action-angle coordinates &mdash; galpy 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="galpy 1.0 documentation" href="index.html" />
    <link rel="next" title="Three-dimensional disk distribution functions" href="diskdf.html" />
    <link rel="prev" title="A closer look at orbit integration" href="orbit.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="diskdf.html" title="Three-dimensional disk distribution functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="orbit.html" title="A closer look at orbit integration"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">galpy 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo-small.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Action-angle coordinates</a><ul>
<li><a class="reference internal" href="#action-angle-coordinates-for-the-isochrone-potential">Action-angle coordinates for the isochrone potential</a></li>
<li><a class="reference internal" href="#action-angle-coordinates-for-spherical-potentials">Action-angle coordinates for spherical potentials</a></li>
<li><a class="reference internal" href="#action-angle-coordinates-using-the-adiabatic-approximation">Action-angle coordinates using the adiabatic approximation</a></li>
<li><a class="reference internal" href="#action-angle-coordinates-using-the-staeckel-approximation">Action-angle coordinates using the Staeckel approximation</a></li>
<li><a class="reference internal" href="#action-angle-coordinates-using-an-orbit-integration-based-approximation">Action-angle coordinates using an orbit-integration-based approximation</a></li>
<li><a class="reference internal" href="#accessing-action-angle-coordinates-for-orbit-instances">Accessing action-angle coordinates for Orbit instances</a></li>
<li><a class="reference internal" href="#example-evidence-for-a-lindblad-resonance-in-the-solar-neighborhood">Example: Evidence for a Lindblad resonance in the Solar neighborhood</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="orbit.html"
                        title="previous chapter">A closer look at orbit integration</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="diskdf.html"
                        title="next chapter">Three-dimensional disk distribution functions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/actionAngle.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="action-angle-coordinates">
<h1>Action-angle coordinates<a class="headerlink" href="#action-angle-coordinates" title="Permalink to this headline">¶</a></h1>
<p>galpy can calculate actions and angles for a large variety of
potentials (any time-independent potential in principle). These are
implemented in a separate module <tt class="docutils literal"><span class="pre">galpy.actionAngle</span></tt>, and the
preferred method for accessing them is through the routines in this
module. There is also some support for accessing the actionAngle
routines as methods of the <tt class="docutils literal"><span class="pre">Orbit</span></tt> class.</p>
<p>Action-angle coordinates can be calculated for the following
potentials/approximations:</p>
<ul class="simple">
<li>Isochrone potential</li>
<li>Spherical potentials</li>
<li>Adiabatic approximation</li>
<li>Staeckel approximation</li>
<li>A general orbit-integration-based technique</li>
</ul>
<p>There are classes corresponding to these different
potentials/approximations and actions, frequencies, and angles can
typically be calculated using these three methods:</p>
<ul class="simple">
<li>__call__: returns the actions</li>
<li>actionsFreqs: returns the actions and the frequencies</li>
<li>actionsFreqsAngles: returns the actions, frequencies, and angles</li>
</ul>
<p>These are not all implemented for each of the cases above yet.</p>
<p>The adiabatic and Staeckel approximation have also been implemented in
C and using grid-based interpolation, for extremely fast action-angle
calculations (see below).</p>
<div class="section" id="action-angle-coordinates-for-the-isochrone-potential">
<h2>Action-angle coordinates for the isochrone potential<a class="headerlink" href="#action-angle-coordinates-for-the-isochrone-potential" title="Permalink to this headline">¶</a></h2>
<p>The isochrone potential is the only potential for which all of the
actions, frequencies, and angles can be calculated analytically. We
can do this in galpy by doing</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">IsochronePotential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleIsochrone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ip</span><span class="o">=</span> <span class="n">IsochronePotential</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="o">=</span> <span class="n">actionAngleIsochrone</span><span class="p">(</span><span class="n">ip</span><span class="o">=</span><span class="n">ip</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">aAI</span></tt> is now an instance that can be used to calculate action-angle
variables for the specific isochrone potential <tt class="docutils literal"><span class="pre">ip</span></tt>. Calling this
instance returns <span class="math">\((J_R,L_Z,J_Z)\)</span></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span> <span class="c">#inputs R,vR,vT,z,vz</span>
<span class="go">(array([ 0.00713759]), array([ 1.1]), array([ 0.00553155]))</span>
</pre></div>
</div>
<p>or for a more eccentric orbit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">(array([ 0.13769498]), array([ 1.3]), array([ 0.02574507]))</span>
</pre></div>
</div>
<p>Note that we can also specify <tt class="docutils literal"><span class="pre">phi</span></tt>, but this is not necessary</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.13769498]), array([ 1.3]), array([ 0.02574507]))</span>
</pre></div>
</div>
<p>We can likewise calculate the frequencies as well</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="o">.</span><span class="n">actionsFreqs</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.13769498]),</span>
<span class="go"> array([ 1.3]),</span>
<span class="go"> array([ 0.02574507]),</span>
<span class="go"> array([ 1.29136096]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.79093738]))</span>
</pre></div>
</div>
<p>The output is <span class="math">\((J_R,L_Z,J_Z,\Omega_R,\Omega_\phi,\Omega_Z)\)</span>. For
any spherical potential, <span class="math">\(\Omega_\phi =
\mathrm{sgn}(L_Z)\Omega_Z\)</span>, such that the last two frequencies are the
same.</p>
<p>We obtain the angles as well by calling</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.13769498]),</span>
<span class="go"> array([ 1.3]),</span>
<span class="go"> array([ 0.02574507]),</span>
<span class="go"> array([ 1.29136096]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.57101518]),</span>
<span class="go"> array([ 5.96238847]),</span>
<span class="go"> array([ 1.24999949]))</span>
</pre></div>
</div>
<p>The output here is
<span class="math">\((J_R,L_Z,J_Z,\Omega_R,\Omega_\phi,\Omega_Z,\theta_R,\theta_\phi,\theta_Z)\)</span>.</p>
<p>To check that these are good action-angle variables, we can calculate
them along an orbit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.orbit</span> <span class="kn">import</span> <span class="n">Orbit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">100.</span><span class="p">,</span><span class="mi">1001</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">ip</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jfa</span><span class="o">=</span> <span class="n">aAI</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
</pre></div>
</div>
<p>which works because we can provide arrays for the <tt class="docutils literal"><span class="pre">R</span></tt> etc. inputs.</p>
<p>We can then check that the actions are constant over the orbit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">jfa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">jfa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">1</span><span class="p">])))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">jfa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">2</span><span class="p">])))))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/ip-actions.png" src="_images/ip-actions.png" />
<p>The actions are all conserved. The angles increase linearly with time</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="s">&#39;b.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="s">&#39;g.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="s">&#39;r.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/ip-tangles.png" src="_images/ip-tangles.png" />
</div>
<div class="section" id="action-angle-coordinates-for-spherical-potentials">
<h2>Action-angle coordinates for spherical potentials<a class="headerlink" href="#action-angle-coordinates-for-spherical-potentials" title="Permalink to this headline">¶</a></h2>
<p>Action-angle coordinates for any spherical potential can be calculated
using a few orbit integrations. These are implemented in galpy in the
<tt class="docutils literal"><span class="pre">actionAngleSpherical</span></tt> module. For example, we can do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">LogarithmicHaloPotential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp</span><span class="o">=</span> <span class="n">LogarithmicHaloPotential</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleSpherical</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleSpherical</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">)</span>
</pre></div>
</div>
<p>For the same eccentric orbit as above we find</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.22022112]), array([ 1.3]), array([ 0.02574507]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqs</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.22022112]),</span>
<span class="go"> array([ 1.3]),</span>
<span class="go"> array([ 0.02574507]),</span>
<span class="go"> array([ 0.87630459]),</span>
<span class="go"> array([ 0.60872881]),</span>
<span class="go"> array([ 0.60872881]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.22022112]),</span>
<span class="go"> array([ 1.3]),</span>
<span class="go"> array([ 0.02574507]),</span>
<span class="go"> array([ 0.87630459]),</span>
<span class="go"> array([ 0.60872881]),</span>
<span class="go"> array([ 0.60872881]),</span>
<span class="go"> array([ 0.40443857]),</span>
<span class="go"> array([ 5.85965048]),</span>
<span class="go"> array([ 1.1472615]))</span>
</pre></div>
</div>
<p>We can again check that the actions are conserved along the orbit and
that the angles increase linearly with time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">lp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jfa</span><span class="o">=</span> <span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>where we use <tt class="docutils literal"><span class="pre">fixed_quad=True</span></tt> for a faster evaluation of the
required one-dimensional integrals using Gaussian quadrature. We then
plot the action fluctuations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">jfa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">0</span><span class="p">])))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">jfa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">1</span><span class="p">])))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">jfa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">2</span><span class="p">])))))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/lp-actions.png" src="_images/lp-actions.png" />
<p>showing that the actions are all conserved. The angles again increase
linearly with time</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="s">&#39;b.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="s">&#39;g.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="s">&#39;r.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/lp-tangles.png" src="_images/lp-tangles.png" />
<p>We can check the spherical action-angle calculations against the
analytical calculations for the isochrone potential. Starting again
from the isochrone potential used in the previous section</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ip</span><span class="o">=</span> <span class="n">IsochronePotential</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="o">=</span> <span class="n">actionAngleIsochrone</span><span class="p">(</span><span class="n">ip</span><span class="o">=</span><span class="n">ip</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleSpherical</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">ip</span><span class="p">)</span>
</pre></div>
</div>
<p>we can compare the actions, frequencies, and angles computed using
both</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAI</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.13769498]),</span>
<span class="go"> array([ 1.3]),</span>
<span class="go"> array([ 0.02574507]),</span>
<span class="go"> array([ 1.29136096]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.57101518]),</span>
<span class="go"> array([ 5.96238847]),</span>
<span class="go"> array([ 1.24999949]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">(array([ 0.13769498]),</span>
<span class="go"> array([ 1.3]),</span>
<span class="go"> array([ 0.02574507]),</span>
<span class="go"> array([ 1.29136096]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.79093738]),</span>
<span class="go"> array([ 0.57101518]),</span>
<span class="go"> array([ 5.96238838]),</span>
<span class="go"> array([ 1.2499994]))</span>
</pre></div>
</div>
<p>or more explicitly comparing the two</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">s</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aAI</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span><span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.3</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">))]</span>
<span class="go">[array([  6.66133815e-16]),</span>
<span class="go"> array([ 0.]),</span>
<span class="go"> array([ 0.]),</span>
<span class="go"> array([ -4.53851845e-10]),</span>
<span class="go"> array([  4.74775219e-10]),</span>
<span class="go"> array([  4.74775219e-10]),</span>
<span class="go"> array([ -1.65965242e-10]),</span>
<span class="go"> array([  9.04759645e-08]),</span>
<span class="go"> array([  9.04759649e-08])]</span>
</pre></div>
</div>
</div>
<div class="section" id="action-angle-coordinates-using-the-adiabatic-approximation">
<h2>Action-angle coordinates using the adiabatic approximation<a class="headerlink" href="#action-angle-coordinates-using-the-adiabatic-approximation" title="Permalink to this headline">¶</a></h2>
<p>For non-spherical, axisymmetric potentials galpy contains multiple
methods for calculating approximate action&#8211;angle coordinates. The
simplest of those is the adiabatic approximation, which works well for
disk orbits that do not go too far from the plane, as it assumes that
the vertical motion is decoupled from that in the plane (e.g.,
<a class="reference external" href="http://adsabs.harvard.edu/abs/2010MNRAS.401.2318B">2010MNRAS.401.2318B</a>).</p>
<p>Setup is similar as for other actionAngle objects</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">MWPotential2014</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleAdiabatic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">)</span>
</pre></div>
</div>
<p>and evaluation then proceeds similarly as before</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">)</span>
<span class="go">(0.01351896260559274, 1.1, 0.0004690133479435352)</span>
</pre></div>
</div>
<p>We can again check that the actions are conserved along the orbit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.orbit</span> <span class="kn">import</span> <span class="n">Orbit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">100.</span><span class="p">,</span><span class="mi">1001</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">MWPotential2014</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js</span><span class="o">=</span> <span class="n">aAA</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
</pre></div>
</div>
<p>This takes a while. The adiabatic approximation is also implemented in
C, which leads to great speed-ups. Here is how to use it</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">))</span>
<span class="go">10 loops, best of 3: 73.7 ms per loop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">))</span>
<span class="go">1000 loops, best of 3: 1.3 ms per loop</span>
</pre></div>
</div>
<p>or about a <em>50 times</em> speed-up. For arrays the speed-up is even more
impressive</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">10 loops, best of 3: 37.8 ms per loop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">)</span> <span class="c">#back to no C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">1 loops, best of 3: 7.71 s per loop</span>
</pre></div>
</div>
<p>or a speed-up of 200! Back to the previous example, you can run it
with <tt class="docutils literal"><span class="pre">c=True</span></tt> to speed up the computation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js</span><span class="o">=</span> <span class="n">aAA</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
</pre></div>
</div>
<p>We can plot the radial- and vertical-action fluctuation as a function
of time</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]))))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/MWPotential-adactions.png" src="_images/MWPotential-adactions.png" />
<p>The radial action is conserved to about half a percent, the vertical
action to two percent.</p>
<p>Another way to speed up the calculation of actions using the adiabatic
approximation is to tabulate the actions on a grid in (approximate)
integrals of the motion and evaluating new actions by interpolating on
this grid. How this is done in practice is described in detail in the
galpy paper. To setup this grid-based interpolation method, which is
contained in <tt class="docutils literal"><span class="pre">actionAngleAdiabaticGrid</span></tt>, do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleAdiabaticGrid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAG</span><span class="o">=</span> <span class="n">actionAngleAdiabaticGrid</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">nR</span><span class="o">=</span><span class="mi">31</span><span class="p">,</span><span class="n">nEz</span><span class="o">=</span><span class="mi">31</span><span class="p">,</span><span class="n">nEr</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">nLz</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">c=True</span></tt> specifies that we use the C implementation of
<tt class="docutils literal"><span class="pre">actionAngleAdiabatic</span></tt> for speed. We can now evaluate in the same
was as before, for example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">),</span> <span class="n">aAG</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">)</span>
<span class="go">((array([ 0.01352523]), array([ 1.1]), array([ 0.00046909])),</span>
<span class="go"> (0.013527010324238781, 1.1, 0.00047747359874375148))</span>
</pre></div>
</div>
<p>which agree very well. To look at the timings, we first switch back to
not using C and then list all of the relevant timings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go"># Not using C, direct calculation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">1 loops, best of 3: 9.05 s per loop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go"># Using C, direct calculation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAA</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">10 loops, best of 3: 39.7 ms per loop</span>
<span class="go"># Grid-based calculation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAG</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">1000 loops, best of 3: 1.09 ms per loop</span>
</pre></div>
</div>
<p>Thus, in this example (and more generally) the grid-based calculation
is significantly faster than even the direct implementation in C. The
overall speed up between the direct Python version and the grid-based
version is larger than 8,000; the speed up between the direct C
version and the grid-based version is 36. For larger arrays of input
phase-space positions, the latter speed up can increase to 150.  For
simpler, fully analytical potentials the speed up will be slightly
less, but for <tt class="docutils literal"><span class="pre">MWPotential2014</span></tt> and other more complicated
potentials (such as those involving a double-exponential disk), the
overhead of setting up the grid is worth it when evaluating more than
a few thousand actions.</p>
<p>The adiabatic approximation works well for orbits that stay close to
the plane. The orbit we have been considering so far only reaches a
height two percent of <span class="math">\(R_0\)</span>, or about 150 pc for <span class="math">\(R_0 = 8\)</span>
kpc.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">zmax</span><span class="p">()</span><span class="o">*</span><span class="mf">8.</span>
<span class="go">0.17903686455491979</span>
</pre></div>
</div>
<p>For orbits that reach distances of a kpc and more from the plane, the
adiabatic approximation does not work as well. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">MWPotential2014</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">zmax</span><span class="p">()</span><span class="o">*</span><span class="mf">8.</span>
<span class="go">1.3506059038621048</span>
</pre></div>
</div>
<p>and we can again calculate the actions along the orbit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">js</span><span class="o">=</span> <span class="n">aAA</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]))))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/MWPotential-adactions-highz.png" src="_images/MWPotential-adactions-highz.png" />
<p>The radial action is now only conserved to about ten percent and the
vertical action to approximately five percent.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Frequencies and angles using the adiabatic approximation are not implemented at this time.</p>
</div>
</div>
<div class="section" id="action-angle-coordinates-using-the-staeckel-approximation">
<h2>Action-angle coordinates using the Staeckel approximation<a class="headerlink" href="#action-angle-coordinates-using-the-staeckel-approximation" title="Permalink to this headline">¶</a></h2>
<p>A better approximation than the adiabatic one is to locally
approximate the potential as a Staeckel potential, for which actions,
frequencies, and angles can be calculated through numerical
integration. galpy contains an implementation of the algorithm of
Binney (2012; <a class="reference external" href="http://adsabs.harvard.edu/abs/2012MNRAS.426.1324B">2012MNRAS.426.1324B</a>), which
accomplishes the Staeckel approximation for disk-like (i.e., oblate)
potentials without explicitly fitting a Staeckel potential. For all
intents and purposes the adiabatic approximation is made obsolete by
this new method, which is as fast and more precise. The only advantage
of the adiabatic approximation over the Staeckel approximation is that
the Staeckel approximation requires the user to specify a <em>focal
length</em> <span class="math">\(\Delta\)</span> to be used in the Staeckel
approximation. However, this focal length can be easily estimated from
the second derivatives of the potential (see Sanders 2012;
<a class="reference external" href="http://adsabs.harvard.edu/abs/2012MNRAS.426..128S">2012MNRAS.426..128S</a>).</p>
<p>Starting from the second orbit example in the adiabatic section above,
we first estimate a good focal length of the <tt class="docutils literal"><span class="pre">MWPotential2014</span></tt> to
use in the Staeckel approximation. We do this by averaging (through
the median) estimates at positions around the orbit (which we
integrated in the example above)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">estimateDeltaStaeckel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimateDeltaStaeckel</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">)</span>
<span class="go">0.40272708556203662</span>
</pre></div>
</div>
<p>We will use <span class="math">\(\Delta = 0.4\)</span> in what follows. We set up the
<tt class="docutils literal"><span class="pre">actionAngleStaeckel</span></tt> object</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleStaeckel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c">#c=True is the default</span>
</pre></div>
</div>
<p>and calculate the actions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">())</span>
<span class="go">(0.019212848866725911, 1.1000000000000001, 0.015274597971510892)</span>
</pre></div>
</div>
<p>The adiabatic approximation from above gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAA</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">())</span>
<span class="go">(array([ 0.01686478]), array([ 1.1]), array([ 0.01590001]))</span>
</pre></div>
</div>
<p>The actionAngleStaeckel calculations are sped up in two ways. First,
the action integrals can be calculated using Gaussian quadrature by
specifying <tt class="docutils literal"><span class="pre">fixed_quad=True</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(),</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(0.01922167296633687, 1.1000000000000001, 0.015276825017286706)</span>
</pre></div>
</div>
<p>which in itself leads to a ten times speed up</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAS</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(),</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">10 loops, best of 3: 129 ms per loop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAS</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(),</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">100 loops, best of 3: 10.3 ms per loop</span>
</pre></div>
</div>
<p>Second, the actionAngleStaeckel calculations have also been
implemented in C, which leads to even greater speed-ups, especially
for arrays</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAS</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">10 loops, best of 3: 35.1 ms per loop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c">#back to no C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAS</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">1 loops, best of 3: 496 ms per loop</span>
</pre></div>
</div>
<p>or a fifteen times speed up. The speed up is not that large because
the bulge model in <tt class="docutils literal"><span class="pre">MWPotential2014</span></tt> requires expensive special
functions to be evaluated. Computations could be sped up ten times
more when using a simpler bulge model.</p>
<p>Similar to <tt class="docutils literal"><span class="pre">actionAngleAdiabaticGrid</span></tt>, we can also tabulate the
actions on a grid of (approximate) integrals of the motion and
interpolate over this look-up table when evaluating new actions. The
details of how this look-up table is setup and used are again fully
explained in the galpy paper. To use this grid-based Staeckel
approximation, contained in <tt class="docutils literal"><span class="pre">actionAngleStaeckelGrid</span></tt>, do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleStaeckelGrid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aASG</span><span class="o">=</span> <span class="n">actionAngleStaeckelGrid</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">nE</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">npsi</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">nLz</span><span class="o">=</span><span class="mi">61</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">c=True</span></tt> makes sure that we use the C implementation of the
Staeckel method to calculate the grid. Because this is a fully
three-dimensional grid, setting up the grid takes longer than it does
for the adiabatic method (which only uses two two-dimensional
grids). We can then evaluate actions as before</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">()),</span> <span class="n">aASG</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">())</span>
<span class="go">((0.019212848866725911, 1.1000000000000001, 0.015274597971510892),</span>
<span class="go"> (0.019221119033345408, 1.1000000000000001, 0.015022528662310393))</span>
</pre></div>
</div>
<p>These actions agree very well. We can compare the timings of these
methods as above</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAS</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">1 loops, best of 3: 576 ms per loop # Not using C, direct calculation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aAS</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">100 loops, best of 3: 17.8 ms per loop # Using C, direct calculation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="p">(</span><span class="n">aASG</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="mf">0.05</span><span class="o">*</span><span class="n">s</span><span class="p">))</span>
<span class="go">100 loops, best of 3: 3.45 ms per loop # Grid-based calculation</span>
</pre></div>
</div>
<p>This demonstrates that the grid-based interpolation again leeds to a
significant speed up, even over the C implementation of the direct
calculation. This speed up becomes more significant for larger array
input, although it saturates at about 25 times (at least for
<tt class="docutils literal"><span class="pre">MWPotential2014</span></tt>).</p>
<p>We can now go back to checking that the actions are conserved along
the orbit (going back to the <tt class="docutils literal"><span class="pre">c=False</span></tt> version of
<tt class="docutils literal"><span class="pre">actionAngleStaeckel</span></tt>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js</span><span class="o">=</span> <span class="n">aAS</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">fixed_quad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">js</span><span class="p">[</span><span class="mi">2</span><span class="p">]))))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/MWPotential-stactions-highz.png" src="_images/MWPotential-stactions-highz.png" />
<p>The radial action is now conserved to better than a percent and the
vertical action to only a fraction of a percent. Clearly, this is much
better than the five to ten percent errors found for the adiabatic
approximation above.</p>
<p>For the Staeckel approximation we can also calculate frequencies and
angles through the <tt class="docutils literal"><span class="pre">actionsFreqs</span></tt> and <tt class="docutils literal"><span class="pre">actionsFreqsAngles</span></tt>
methods.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Frequencies and angles using the Staeckel approximation
are <em>only</em> implemented in C. So use <tt class="docutils literal"><span class="pre">c=True</span></tt> in the setup of the
actionAngleStaeckel object.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Angles using the Staeckel approximation in galpy are such
that (a) the radial angle starts at zero at pericenter and
increases then going toward apocenter; (b) the vertical angle
starts at zero at <em>z=0</em> and increases toward positive zmax. The
latter is a different convention from that in Binney (2012), but is
consistent with that in actionAngleIsochrone and
actionAngleSpherical.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span> <span class="c">#need to specify phi for angles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(),</span><span class="n">o</span><span class="o">.</span><span class="n">phi</span><span class="p">())</span>
<span class="go">(array([ 0.01922167]),</span>
<span class="go"> array([ 1.1]),</span>
<span class="go"> array([ 0.01527683]),</span>
<span class="go"> array([ 1.11317796]),</span>
<span class="go"> array([ 0.82538032]),</span>
<span class="go"> array([ 1.34126138]),</span>
<span class="go"> array([ 0.37758087]),</span>
<span class="go"> array([ 6.17833493]),</span>
<span class="go"> array([ 6.13368239]))</span>
</pre></div>
</div>
<p>and we can check that the angles increase linearly along the orbit</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">MWPotential2014</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jfa</span><span class="o">=</span> <span class="n">aAS</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vR</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vT</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">vz</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="s">&#39;b.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span><span class="s">&#39;g.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">jfa</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="s">&#39;r.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/MWPotential-tangles.png" src="_images/MWPotential-tangles.png" />
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">jfa</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="n">jfa</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="s">&#39;b.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/MWPotential-angles.png" src="_images/MWPotential-angles.png" />
</div>
<div class="section" id="action-angle-coordinates-using-an-orbit-integration-based-approximation">
<h2>Action-angle coordinates using an orbit-integration-based approximation<a class="headerlink" href="#action-angle-coordinates-using-an-orbit-integration-based-approximation" title="Permalink to this headline">¶</a></h2>
<p>The adiabatic and Staeckel approximations used above are good for
stars on close-to-circular orbits, but they break down for more
eccentric orbits (specifically, orbits for which the radial and/or
vertical action is of a similar magnitude as the angular
momentum). This is because the approximations made to the potential in
these methods (that it is separable in <em>R</em> and <em>z</em> for the adiabatic
approximation and that it is close to a Staeckel potential for the
Staeckel approximation) break down for such orbits. Unfortunately,
these methods cannot be refined to provide better approximations for
eccentric orbits.</p>
<p>galpy contains a new method for calculating actions, frequencies, and
angles that is completely general for any static potential. It can
calculate the actions to any desired precision for any orbit in such
potentials. The method works by employing an auxiliary isochrone
potential and calculates action-angle variables by arithmetic
operations on the actions and angles calculated in the auxiliary
potential along an orbit (integrated in the true potential). Full
details can be found in Appendix A of Bovy (2014).</p>
<p>We setup this method for a logarithmic potential as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleIsochroneApprox</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">LogarithmicHaloPotential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp</span><span class="o">=</span> <span class="n">LogarithmicHaloPotential</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">=</span> <span class="n">actionAngleIsochroneApprox</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">b=0.8</span></tt> here sets the scale parameter of the auxiliary isochrone
potential; this potential can also be specified as an
IsochronePotential instance through <tt class="docutils literal"><span class="pre">ip=</span></tt>). We can now calculate the
actions for an orbit similar to that of the GD-1 stream</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">obs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.56148083</span><span class="p">,</span><span class="mf">0.35081535</span><span class="p">,</span><span class="o">-</span><span class="mf">1.15481504</span><span class="p">,</span><span class="mf">0.88719443</span><span class="p">,</span><span class="o">-</span><span class="mf">0.47713334</span><span class="p">,</span><span class="mf">0.12019596</span><span class="p">])</span> <span class="c">#orbit similar to GD-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">)</span>
<span class="go">(array([ 0.16605011]), array([-1.80322155]), array([ 0.50704439]))</span>
</pre></div>
</div>
<p>An essential requirement of this method is that the angles calculated
in the auxiliary potential go through the full range
<span class="math">\([0,2\pi]\)</span>. If this is not the case, galpy will raise a warning</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">=</span> <span class="n">actionAngleIsochroneApprox</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">10.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">)</span>
<span class="go">galpyWarning: Full radial angle range not covered for at least one object; actions are likely not reliable</span>
<span class="go">(array([ 0.08985167]), array([-1.80322155]), array([ 0.50849276]))</span>
</pre></div>
</div>
<p>Therefore, some care should be taken to choosing a good auxiliary
potential. galpy contains a method to estimate a decent scale
parameter for the auxiliary scale parameter, which works similar to
<tt class="docutils literal"><span class="pre">estimateDeltaStaeckel</span></tt> above except that it also gives a minimum
and maximum b if multiple <em>R</em> and <em>z</em> are given</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">estimateBIsochrone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.orbit</span> <span class="kn">import</span> <span class="n">Orbit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">100.</span><span class="p">,</span><span class="mi">1001</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">lp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimateBIsochrone</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">R</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">)</span>
<span class="go">(0.78065062339131952, 1.2265541473461612, 1.4899326335155412) #bmin,bmedian,bmax over the orbit</span>
</pre></div>
</div>
<p>Experience shows that a scale parameter somewhere in the range
returned by this function makes sure that the angles go through the
full <span class="math">\([0,2\pi]\)</span> range. However, even if the angles go through
the full range, the closer the angles increase to linear, the better
the converenge of the algorithm is (and especially, the more accurate
the calculation of the frequencies and angles is, see below). For
example, for the scale parameter at the upper and of the range</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">=</span> <span class="n">actionAngleIsochroneApprox</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">)</span>
<span class="go">(array([ 0.01120145]), array([-1.80322155]), array([ 0.50788893]))</span>
</pre></div>
</div>
<p>which does not agree with the previous calculation. We can inspect how
the angles increase and how the actions converge by using the
<tt class="docutils literal"><span class="pre">aAIA.plot</span></tt> function. For example, we can plot the radial versus the
vertical angle in the auxiliary potential</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;araz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/aAIA-b1.5-araz.png" src="_images/aAIA-b1.5-araz.png" />
<p>and this clearly shows that the angles increase <em>very</em> non-linearly,
because the auxiliary isochrone potential used is too far from the
real potential. This causes the actions to converge only very
slowly. For example, for the radial action we can plot the converge as a function of integration time</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;jr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/aAIA-b1.5-jr.png" src="_images/aAIA-b1.5-jr.png" />
<p>This Figure clearly shows that the radial action has not converged
yet. We need to integrate <em>much</em> longer in this auxiliary potential to
obtain convergence and because the angles increase so non-linearly, we also need to integrate the orbit much more finely:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">=</span> <span class="n">actionAngleIsochroneApprox</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">tintJ</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">ntintJ</span><span class="o">=</span><span class="mi">800000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">)</span>
<span class="go">(array([ 0.01711635]), array([-1.80322155]), array([ 0.51008058]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;jr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which shows slow convergence</p>
<img alt="_images/aAIA-b1.5-jrlong.png" src="_images/aAIA-b1.5-jrlong.png" />
<p>Finding a better auxiliary potential makes convergence <em>much</em> faster
and also allows the frequencies and the angles to be calculated by
removing the small wiggles in the auxiliary angles vs. time (in the
angle plot above, the wiggles are much larger, such that removing them
is hard). The auxiliary potential used above had <tt class="docutils literal"><span class="pre">b=0.8</span></tt>, which
shows very quick converenge and good behavior of the angles</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">=</span> <span class="n">actionAngleIsochroneApprox</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">lp</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;jr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>gives</p>
<img alt="_images/aAIA-b0.8-jr.png" src="_images/aAIA-b0.8-jr.png" />
<p>and</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;araz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>gives</p>
<img alt="_images/aAIA-b0.8-araz.png" src="_images/aAIA-b0.8-araz.png" />
<p>We can remove the periodic behavior from the angles, which clearly
shows that they increase close-to-linear with time</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;araz&#39;</span><span class="p">,</span><span class="n">deperiod</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/aAIA-b0.8-arazdeperiod.png" src="_images/aAIA-b0.8-arazdeperiod.png" />
<p>We can then calculate the frequencies and the angles for this orbit as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">)</span>
<span class="go">(array([ 0.16392384]),</span>
<span class="go"> array([-1.80322155]),</span>
<span class="go"> array([ 0.50999882]),</span>
<span class="go"> array([ 0.55808933]),</span>
<span class="go"> array([-0.38475753]),</span>
<span class="go"> array([ 0.42199713]),</span>
<span class="go"> array([ 0.18739688]),</span>
<span class="go"> array([ 0.3131815]),</span>
<span class="go"> array([ 2.18425661]))</span>
</pre></div>
</div>
<p>This function takes as an argument <tt class="docutils literal"><span class="pre">maxn=</span></tt> the maximum <em>n</em> for which
to remove sinusoidal wiggles. So we can raise this, for example to 4
from 3</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="o">.</span><span class="n">actionsFreqsAngles</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="n">maxn</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">(array([ 0.16392384]),</span>
<span class="go"> array([-1.80322155]),</span>
<span class="go"> array([ 0.50999882]),</span>
<span class="go"> array([ 0.55808776]),</span>
<span class="go"> array([-0.38475733]),</span>
<span class="go"> array([ 0.4219968]),</span>
<span class="go"> array([ 0.18732009]),</span>
<span class="go"> array([ 0.31318534]),</span>
<span class="go"> array([ 2.18421296]))</span>
</pre></div>
</div>
<p>Clearly, there is very little change, as most of the wiggles are of
low <em>n</em>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">While the orbit-based actionAngle technique in principle works for triaxial potentials, angles and frequencies for non-axisymmetric potentials are not implemented yet.</p>
</div>
<p>This technique also works for triaxial potentials, but using those
requires the code to also use the azimuthal angle variable in the
auxiliary potential (this is unnecessary in axisymmetric potentials as
the <em>z</em> component of the angular momentum is conserved). We can
calculate actions for triaxial potentials by specifying that
<tt class="docutils literal"><span class="pre">nonaxi=True</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aAIA</span><span class="p">(</span><span class="o">*</span><span class="n">obs</span><span class="p">,</span><span class="n">nonaxi</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(array([ 0.16605011]), array([-1.80322155]), array([ 0.50704439]))</span>
</pre></div>
</div>
<p>galpy currently does not contain any triaxial potentials, so we cannot
illustrate this here with any real triaxial potentials.</p>
</div>
<div class="section" id="accessing-action-angle-coordinates-for-orbit-instances">
<h2>Accessing action-angle coordinates for Orbit instances<a class="headerlink" href="#accessing-action-angle-coordinates-for-orbit-instances" title="Permalink to this headline">¶</a></h2>
<p>While the recommended way to access the actionAngle routines is
through the methods in the <tt class="docutils literal"><span class="pre">galpy.actionAngle</span></tt> modules, action-angle
coordinates can also be cacluated for <tt class="docutils literal"><span class="pre">galpy.orbit.Orbit</span></tt>
instances. This is illustrated here briefly. We initialize an Orbit
instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.orbit</span> <span class="kn">import</span> <span class="n">Orbit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">MWPotential2014</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
</pre></div>
</div>
<p>and we can then calculate the actions (default is to use the adiabatic
approximation)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">jp</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">jz</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">)</span>
<span class="go">(0.01685643005901713, 1.1, 0.015897730620467752)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">o.jp</span></tt> here gives the azimuthal action (which is the <em>z</em> component
of the angular momentum for axisymmetric potentials). We can also use
the other methods described above, but note that these require extra
parameters related to the approximation to be specified (see above):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">jp</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">jz</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="go">(array([ 0.01922167]), array([ 1.1]), array([ 0.01527683]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">jp</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">jz</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">(array([ 0.01906609]), array([ 1.1]), array([ 0.01528049]))</span>
</pre></div>
</div>
<p>These two methods give very precise actions for this orbit (both are
converged to about 1%) and they agree very well</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span><span class="o">-</span><span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">))</span><span class="o">/</span><span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">array([ 0.00816012])</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">jz</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span><span class="o">-</span><span class="n">o</span><span class="o">.</span><span class="n">jz</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">))</span><span class="o">/</span><span class="n">o</span><span class="o">.</span><span class="n">jz</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">array([-0.00024])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Once an action, frequency, or angle is calculated for a given type of calculation (e.g., staeckel), the parameters for that type are fixed in the Orbit instance. Call o.resetaA() to reset the action-angle instance used when using different parameters (i.e., different <tt class="docutils literal"><span class="pre">delta=</span></tt> for staeckel or different <tt class="docutils literal"><span class="pre">b=</span></tt> for isochroneApprox.</p>
</div>
<p>We can also calculate the frequencies and the angles. This requires
using the Staeckel or Isochrone approximations, because frequencies
and angles are currently not supported for the adiabatic
approximation. For example, the radial frequency</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="go">1.1131779637307115</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">1.1134635974560649</span>
</pre></div>
</div>
<p>and the radial angle</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">wr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;staeckel&#39;</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="go">0.37758086786371969</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">wr</span><span class="p">(</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;isochroneApprox&#39;</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">0.38159809018175395</span>
</pre></div>
</div>
<p>which again agree to 1%. We can also calculate the other frequencies,
angles, as well as periods using the functions <tt class="docutils literal"><span class="pre">o.Op</span></tt>, <tt class="docutils literal"><span class="pre">o.oz</span></tt>,
<tt class="docutils literal"><span class="pre">o.wp</span></tt>, <tt class="docutils literal"><span class="pre">o.wz</span></tt>, <tt class="docutils literal"><span class="pre">o.Tr</span></tt>, <tt class="docutils literal"><span class="pre">o.Tp</span></tt>, <tt class="docutils literal"><span class="pre">o.Tz</span></tt>.</p>
</div>
<div class="section" id="example-evidence-for-a-lindblad-resonance-in-the-solar-neighborhood">
<h2>Example: Evidence for a Lindblad resonance in the Solar neighborhood<a class="headerlink" href="#example-evidence-for-a-lindblad-resonance-in-the-solar-neighborhood" title="Permalink to this headline">¶</a></h2>
<p>We can use galpy to calculate action-angle coordinates for a set of
stars in the Solar neighborhood and look for unexplained features. For
this we download the data from the Geneva-Copenhagen Survey
(<a class="reference external" href="http://adsabs.harvard.edu/abs/2009A&amp;A...501..941H">2009A&amp;A...501..941H</a>; data available
at <a class="reference external" href="http://vizier.cfa.harvard.edu/viz-bin/VizieR?-source=V/130/">viZier</a>). Since
the velocities in this catalog are given as U,V, and W, we use the
<tt class="docutils literal"><span class="pre">radec</span></tt> and <tt class="docutils literal"><span class="pre">UVW</span></tt> keywords to initialize the orbits from the raw
data. For each object <tt class="docutils literal"><span class="pre">ii</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">Orbit</span><span class="p">(</span><span class="n">vxvv</span><span class="p">[</span><span class="n">ii</span><span class="p">,:],</span><span class="n">radec</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">uvw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">vo</span><span class="o">=</span><span class="mf">220.</span><span class="p">,</span><span class="n">ro</span><span class="o">=</span><span class="mf">8.</span><span class="p">)</span>
</pre></div>
</div>
<p>We then calculate the actions and angles for each object in a flat
rotation curve potential</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lp</span><span class="o">=</span> <span class="n">LogarithmicHaloPotential</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myjr</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>
</pre></div>
</div>
<p>etc.</p>
<p>Plotting the radial action versus the angular momentum</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="o">.</span><span class="n">bovy_plot</span><span class="p">(</span><span class="n">myjp</span><span class="p">,</span><span class="n">myjr</span><span class="p">,</span><span class="s">&#39;k.&#39;</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s">r&#39;$J_{\phi}$&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">r&#39;$J_R$&#39;</span><span class="p">,</span><span class="nb">xrange</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">1.3</span><span class="p">],</span><span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.05</span><span class="p">])</span>
</pre></div>
</div>
<p>shows a feature in the distribution</p>
<img alt="_images/actionAngle-jrjp.png" src="_images/actionAngle-jrjp.png" />
<p>If instead we use a power-law rotation curve with power-law index 1</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pp</span><span class="o">=</span> <span class="n">PowerSphericalPotential</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">alpha</span><span class="o">=-</span><span class="mf">2.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myjr</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">jr</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
</pre></div>
</div>
<p>We find that the distribution is stretched, but the feature remains</p>
<img alt="_images/actionAngle-jrjp-power.png" src="_images/actionAngle-jrjp-power.png" />
<p>Code for this example can be found <a class="reference download internal" href="_downloads/sellwood-jrjp.py"><tt class="xref download docutils literal"><span class="pre">here</span></tt></a> (note that this code uses a particular
download of the GCS data set; if you use your own version, you will
need to modify the part of the code that reads the data). For more
information see <a class="reference external" href="http://adsabs.harvard.edu/abs/2010MNRAS.409..145S">2010MNRAS.409..145S</a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="diskdf.html" title="Three-dimensional disk distribution functions"
             >next</a> |</li>
        <li class="right" >
          <a href="orbit.html" title="A closer look at orbit integration"
             >previous</a> |</li>
        <li><a href="index.html">galpy 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010 - 2014, Jo Bovy.
      Last updated on Dec 07, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>